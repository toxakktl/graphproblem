# graphproblem
Приложение находит путь между двумя вершинами в неориентированном и невзвешенном графе. (На самом деле в моем алгоритме находит кратчайший путь) В качестве входящих параметров принимает любые типы данных. После добавления первой вершины, граф будет работать с типами первой вершины, иначе вернет ошибку.
При запуске создаст папку logs в корне (для демонстрации разместил в корень) и будет писать логи в файл graphlogs.log и в консоль.
Тесты Junit 5 Jupiter в классе GraphProblemApplicationTests. запускаются при gradle build и gradle bootRun

Технологии, которые использовлись в приложении:

1) Spring Boot
2) Gradle
3) Spring validation
4) Junit 5
5) Log4j2

В приложении есть следующие REST :

1. GET запрос. http://localhost:8080/graph/get

Возвращает текущий граф в виде adjecncy list. Элементы и их соседи в виде списка.
Пример ответа: 
{
    "httpcode": 200,
    "description": "Текущий граф",
    "timestamp": "2019-02-05 10:45:36",
    "data": {
        "adjacencyList": {
            "A": [
                "B"
            ],
            "B": [
                "A",
                "C"
            ],
            "C": [
                "B"
            ]
        }
    }
}

2. POST запрос http://localhost:8080/graph/vertices/add

Добавляет вершину в граф. Если это первый элемент, который добавляется в граф - задается тип с которым будет работать граф.

{
	"vertex": "А"
}

Пример успешного ответа:
{
    "httpcode": 200,
    "description": "Вершина A добавлена.",
    "timestamp": "2019-02-05 10:49:06"
}

Пример не успешного ответа:

{
    "httpcode": 400,
    "description": "Вершина A уже есть в графе",
    "timestamp": "2019-02-05 10:49:32"
}

3. POST запрос http://localhost:8080/graph/vertices/remove

Удаляет вершину с графа, если такая вершина существет в графе.

{
	"vertex": "А"
}

Пример успешного ответа:

{
    "httpcode": 200,
    "description": "Вершина A удалена.",
    "timestamp": "2019-02-05 10:52:04"
}

Пример не успешного ответа:

{
    "httpcode": 400,
    "description": "Вершины A нет в графе",
    "timestamp": "2019-02-05 10:52:13"
}

4. POST запрос http://localhost:8080/graph/edges/add

Добавляет ребро между двумя вершинами

{
	"src":"A",
	"dst":"B"
}

Пример успешного ответа:
{
    "httpcode": 200,
    "description": "Ребро A-B добавлено.",
    "timestamp": "2019-02-05 10:54:57"
}

Пример не успешного ответа:

{
    "httpcode": 400,
    "description": "Заданное ребро существует",
    "timestamp": "2019-02-05 10:56:12"
}

5. POST запрос http://localhost:8080/graph/edges/remove

Удаляет ребро между двумя вершинами.

{
	"src":"A",
	"dst":"B"
}

Пример успешного ответа:
{
    "httpcode": 200,
    "description": "Ребро A-B удалено.",
    "timestamp": "2019-02-05 10:57:03"
}

Пример не успешного ответа:

{
    "httpcode": 400,
    "description": "Заданное ребро не существует",
    "timestamp": "2019-02-05 10:57:23"
}

6. POST запрос http://localhost:8080/graph/find

Находит путь между двумя вершинами

{
	"src":"A",
	"dst":"D"
}

Пример успешного ответа, если были добавлены вершины A, B, C, D в ребра А-B, B-C, C-D. Очередность соблюдается в объекте data

{
    "httpcode": 200,
    "description": "Путь между A и D.",
    "timestamp": "2019-02-05 11:00:48",
    "data": [
        "A",
        "B",
        "C",
        "D"
    ]
}

Пример не успешного ответа:

{
    "httpcode": 400,
    "description": "Вершина не существует",
    "timestamp": "2019-02-05 11:01:42"
}
